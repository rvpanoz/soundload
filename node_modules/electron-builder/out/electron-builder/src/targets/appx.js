"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

exports.quoteString = quoteString;

var _debug2;

function _load_debug() {
    return _debug2 = _interopRequireDefault(require("debug"));
}

var _electronBuilderUtil;

function _load_electronBuilderUtil() {
    return _electronBuilderUtil = require("electron-builder-util");
}

var _fs;

function _load_fs() {
    return _fs = require("electron-builder-util/out/fs");
}

var _promise;

function _load_promise() {
    return _promise = require("electron-builder-util/out/promise");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _path = _interopRequireWildcard(require("path"));

var _deepAssign;

function _load_deepAssign() {
    return _deepAssign = require("read-config-file/out/deepAssign");
}

var _core;

function _load_core() {
    return _core = require("../core");
}

var _asyncTaskManager;

function _load_asyncTaskManager() {
    return _asyncTaskManager = require("../util/asyncTaskManager");
}

var _windowsCodeSign;

function _load_windowsCodeSign() {
    return _windowsCodeSign = require("../windowsCodeSign");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

const APPX_ASSETS_DIR_NAME = "appx";
const vendorAssetsForDefaultAssets = {
    "StoreLogo.png": "SampleAppx.50x50.png",
    "Square150x150Logo.png": "SampleAppx.150x150.png",
    "Square44x44Logo.png": "SampleAppx.44x44.png",
    "Wide310x150Logo.png": "SampleAppx.310x150.png"
};
const DEFAULT_RESOURCE_LANG = "en-US";
const debug = (0, (_debug2 || _load_debug()).default)("electron-builder:appx");
class AppXTarget extends (_core || _load_core()).Target {
    constructor(packager, outDir) {
        super("appx");
        this.packager = packager;
        this.outDir = outDir;
        this.options = (0, (_deepAssign || _load_deepAssign()).deepAssign)({}, this.packager.platformSpecificBuildOptions, this.packager.config.appx);
        if (process.platform !== "win32" || (0, (_windowsCodeSign || _load_windowsCodeSign()).isOldWin6)()) {
            throw new Error("AppX is supported only on Windows 10 or Windows Server 2012 R2 (version number 6.3+)");
        }
    }
    build(appOutDir, arch) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = _this.packager;
            const cscInfo = yield _this.packager.cscInfo.value;
            if (cscInfo == null) {
                throw new Error("AppX package must be signed, but certificate is not set, please see https://github.com/electron-userland/electron-builder/wiki/Code-Signing\n\nYou can use `./node_modules/.bin/create-self-signed-cert -p YourName` to create self-signed certificate");
            }
            let publisher = _this.options.publisher;
            if (publisher == null) {
                const cscFile = cscInfo.file;
                if (cscFile == null) {
                    throw new Error("Please specify appx.publisher: cannot get publisher from your code signing certificate if EV cert is used");
                }
                publisher = yield packager.computedPublisherSubjectOnWindowsOnly.value;
                if (!publisher) {
                    throw new Error("Please specify appx.publisher, cannot compute from p12 file");
                }
            }
            const preAppx = _path.join(_this.outDir, `pre-appx-${(0, (_electronBuilderUtil || _load_electronBuilderUtil()).getArchSuffix)(arch)}`);
            yield (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(preAppx);
            const resourceList = yield packager.resourceList;
            if (resourceList.indexOf(APPX_ASSETS_DIR_NAME) !== -1) {
                yield (0, (_fs || _load_fs()).copyDir)(_path.join(packager.buildResourcesDir, APPX_ASSETS_DIR_NAME), _path.join(preAppx, "assets"));
            }
            const userAssets = yield (0, (_promise || _load_promise()).orIfFileNotExist)((0, (_fsExtraP || _load_fsExtraP()).readdir)(_path.join(packager.buildResourcesDir, APPX_ASSETS_DIR_NAME)), []);
            const vendorPath = yield (0, (_windowsCodeSign || _load_windowsCodeSign()).getSignVendorPath)();
            const taskManager = new (_asyncTaskManager || _load_asyncTaskManager()).AsyncTaskManager(packager.info.cancellationToken);
            taskManager.addTask((_bluebirdLst2 || _load_bluebirdLst2()).default.map(Object.keys(vendorAssetsForDefaultAssets), function (defaultAsset) {
                if (!isDefaultAssetIncluded(userAssets, defaultAsset)) {
                    return (0, (_fs || _load_fs()).copyFile)(_path.join(vendorPath, "appxAssets", vendorAssetsForDefaultAssets[defaultAsset]), _path.join(preAppx, "assets", defaultAsset));
                }
                return null;
            }));
            taskManager.addTask(_this.writeManifest(_path.join(__dirname, "..", "..", "templates", "appx"), preAppx, arch, publisher, userAssets));
            taskManager.addTask((0, (_fs || _load_fs()).copyDir)(appOutDir, _path.join(preAppx, "app")));
            yield taskManager.awaitTasks();
            const destination = _path.join(_this.outDir, packager.expandArtifactNamePattern(_this.options, "appx", arch));
            const makeAppXArgs = ["pack", "/o", "/d", preAppx, "/p", destination];
            // we do not use process.arch to build path to tools, because even if you are on x64, ia32 appx tool must be used if you build appx for ia32
            if (isScaledAssetsProvided(userAssets)) {
                const priConfigPath = _path.join(preAppx, "priconfig.xml");
                const makePriPath = _path.join(vendorPath, "windows-10", (_electronBuilderUtil || _load_electronBuilderUtil()).Arch[arch], "makepri.exe");
                yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).spawn)(makePriPath, ["createconfig", "/cf", priConfigPath, "/dq", "en-US", "/pv", "10.0.0", "/o"], undefined, { isDebugEnabled: debug.enabled });
                yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).spawn)(makePriPath, ["new", "/pr", preAppx, "/cf", priConfigPath, "/of", preAppx], undefined, { isDebugEnabled: debug.enabled });
                makeAppXArgs.push("/l");
            }
            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(_this.options.makeappxArgs, function (it) {
                return makeAppXArgs.push.apply(makeAppXArgs, _toConsumableArray(it));
            });
            // wine supports only ia32 binary in any case makeappx crashed on wine
            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).spawn)(_path.join(vendorPath, "windows-10", (_electronBuilderUtil || _load_electronBuilderUtil()).Arch[arch], "makeappx.exe"), makeAppXArgs, undefined, { isDebugEnabled: debug.enabled });
            yield packager.sign(destination);
            packager.info.dispatchArtifactCreated({
                file: destination,
                packager,
                arch,
                safeArtifactName: packager.computeSafeArtifactName("appx"),
                target: _this,
                isWriteUpdateInfo: _this.options.electronUpdaterAware
            });
        })();
    }
    writeManifest(templatePath, preAppx, arch, publisher, userAssets) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const appInfo = _this2.packager.appInfo;
            const options = _this2.options;
            const manifest = (yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_path.join(templatePath, "appxmanifest.xml"), "utf8")).replace(/\$\{([a-zA-Z0-9]+)\}/g, function (match, p1) {
                switch (p1) {
                    case "publisher":
                        return publisher;
                    case "publisherDisplayName":
                        const name = options.publisherDisplayName || appInfo.companyName;
                        if (name == null) {
                            throw new Error(`Please specify "author" in the application package.json â€” it is required because "appx.publisherDisplayName" is not set.`);
                        }
                        return name;
                    case "version":
                        return appInfo.versionInWeirdWindowsForm;
                    case "name":
                        return appInfo.name;
                    case "identityName":
                        return options.identityName || appInfo.name;
                    case "executable":
                        return `app\\${appInfo.productFilename}.exe`;
                    case "displayName":
                        return options.displayName || appInfo.productName;
                    case "description":
                        return appInfo.description || appInfo.productName;
                    case "backgroundColor":
                        return options.backgroundColor || "#464646";
                    case "logo":
                        return "assets\\StoreLogo.png";
                    case "square150x150Logo":
                        return "assets\\Square150x150Logo.png";
                    case "square44x44Logo":
                        return "assets\\Square44x44Logo.png";
                    case "lockScreen":
                        return lockScreenTag(userAssets);
                    case "defaultTile":
                        return defaultTileTag(userAssets);
                    case "splashScreen":
                        return splashScreenTag(userAssets);
                    case "arch":
                        return arch === (_electronBuilderUtil || _load_electronBuilderUtil()).Arch.ia32 ? "x86" : "x64";
                    case "resourceLanguages":
                        return resourceLanguageTag((0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(options.languages));
                    default:
                        throw new Error(`Macro ${p1} is not defined`);
                }
            });
            yield (0, (_fsExtraP || _load_fsExtraP()).writeFile)(_path.join(preAppx, "appxmanifest.xml"), manifest);
        })();
    }
}
exports.default = AppXTarget; // get the resource - language tag, see https://docs.microsoft.com/en-us/windows/uwp/globalizing/manage-language-and-region#specify-the-supported-languages-in-the-apps-manifest

function resourceLanguageTag(userLanguages) {
    if (userLanguages == null || userLanguages.length === 0) {
        userLanguages = [DEFAULT_RESOURCE_LANG];
    }
    return userLanguages.map(it => `<Resource Language="${it.replace(/_/g, "-")}" />`).join("\n");
}
function lockScreenTag(userAssets) {
    if (isDefaultAssetIncluded(userAssets, "BadgeLogo.png")) {
        return '<uap:LockScreen Notification="badgeAndTileText" BadgeLogo="assets\\BadgeLogo.png" />';
    } else {
        return "";
    }
}
function defaultTileTag(userAssets) {
    const defaultTiles = ["<uap:DefaultTile", 'Wide310x150Logo="assets\\Wide310x150Logo.png"'];
    if (isDefaultAssetIncluded(userAssets, "LargeTile.png")) {
        defaultTiles.push('Square310x310Logo="assets\\LargeTile.png"');
    }
    if (isDefaultAssetIncluded(userAssets, "SmallTile.png")) {
        defaultTiles.push('Square71x71Logo="assets\\SmallTile.png"');
    }
    defaultTiles.push("/>");
    return defaultTiles.join(" ");
}
function splashScreenTag(userAssets) {
    if (isDefaultAssetIncluded(userAssets, "SplashScreen.png")) {
        return '<uap:SplashScreen Image="assets\\SplashScreen.png" />';
    } else {
        return "";
    }
}
function isDefaultAssetIncluded(userAssets, defaultAsset) {
    const defaultAssetName = defaultAsset.split(".")[0];
    return userAssets.some(it => it.indexOf(defaultAssetName) !== -1);
}
function isScaledAssetsProvided(userAssets) {
    // noinspection SpellCheckingInspection
    return userAssets.some(it => it.indexOf(".scale-") !== -1 || it.indexOf(".targetsize-") !== -1);
}
function quoteString(s) {
    if (!(s.indexOf(",") !== -1) && !(s.indexOf('"') !== -1)) {
        return s;
    }
    return `"${s.replace(/"/g, '\\"')}"`;
}
//# sourceMappingURL=appx.js.map