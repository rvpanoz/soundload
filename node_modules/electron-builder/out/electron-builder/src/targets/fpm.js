"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

let writeConfigFile = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (tmpDir, templatePath, options) {
        //noinspection JSUnusedLocalSymbols
        function replacer(match, p1) {
            if (p1 in options) {
                return options[p1];
            } else {
                throw new Error(`Macro ${p1} is not defined`);
            }
        }
        const config = (yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(templatePath, "utf8")).replace(/\$\{([a-zA-Z]+)\}/g, replacer).replace(/<%=([a-zA-Z]+)%>/g, function (match, p1) {
            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).warn)("<%= varName %> is deprecated, please use ${varName} instead");
            return replacer(match, p1.trim());
        });
        const outputPath = yield tmpDir.getTempFile(_path.basename(templatePath, ".tpl"));
        yield (0, (_fsExtraP || _load_fsExtraP()).outputFile)(outputPath, config);
        return outputPath;
    });

    return function writeConfigFile(_x, _x2, _x3) {
        return _ref.apply(this, arguments);
    };
})();
//# sourceMappingURL=fpm.js.map


var _electronBuilderUtil;

function _load_electronBuilderUtil() {
    return _electronBuilderUtil = require("electron-builder-util");
}

var _binDownload;

function _load_binDownload() {
    return _binDownload = require("electron-builder-util/out/binDownload");
}

var _bundledTool;

function _load_bundledTool() {
    return _bundledTool = require("electron-builder-util/out/bundledTool");
}

var _fs;

function _load_fs() {
    return _fs = require("electron-builder-util/out/fs");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _path = _interopRequireWildcard(require("path"));

var _core;

function _load_core() {
    return _core = require("../core");
}

var _errorMessages;

function _load_errorMessages() {
    return _errorMessages = _interopRequireWildcard(require("../errorMessages"));
}

var _LinuxTargetHelper;

function _load_LinuxTargetHelper() {
    return _LinuxTargetHelper = require("./LinuxTargetHelper");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

const fpmPath = process.platform === "win32" || process.env.USE_SYSTEM_FPM === "true" ? (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve("fpm") : downloadFpm();
// can be called in parallel, all calls for the same version will get the same promise - will be downloaded only once
function downloadFpm() {
    const version = process.platform === "darwin" ? "fpm-1.8.1-20150715-2.2.2" : "fpm-1.8.1-2.3.1";
    const osAndArch = process.platform === "darwin" ? "mac" : `linux-x86${process.arch === "ia32" ? "" : "_64"}`;
    //noinspection SpellCheckingInspection
    const sha2 = process.platform === "darwin" ? "97352e184a1f54e5ed0d12f38ac383edebbe421db5a3fb59898e8c9a1c407ed7" : process.arch === "ia32" ? "8380331f7d9762a36d7c7181501c3fc9342745b8499b962f6ea37c7dc3778f99" : "6538fcd2486c2831949562abfd0017b67eff502addad5b444baec4899b0babc6";
    return (0, (_binDownload || _load_binDownload()).getBin)("fpm", version, `https://dl.bintray.com/electron-userland/bin/${version}-${osAndArch}.7z`, sha2).then(it => _path.join(it, "fpm"));
}
class FpmTarget extends (_core || _load_core()).Target {
    constructor(name, packager, helper, outDir) {
        super(name, false);
        this.packager = packager;
        this.helper = helper;
        this.outDir = outDir;
        this.options = Object.assign({}, this.packager.platformSpecificBuildOptions, this.packager.config[this.name]);
        this.scriptFiles = this.createScripts();
    }
    createScripts() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const defaultTemplatesDir = _path.join(__dirname, "..", "..", "templates", "linux");
            const packager = _this.packager;
            const templateOptions = Object.assign({
                // old API compatibility
                executable: packager.executableName, productFilename: packager.appInfo.productFilename }, packager.platformSpecificBuildOptions);
            function getResource(value, defaultFile) {
                if (value == null) {
                    return _path.join(defaultTemplatesDir, defaultFile);
                }
                return _path.resolve(packager.projectDir, value);
            }
            //noinspection ES6MissingAwait
            return yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([writeConfigFile(packager.info.tempDirManager, getResource(_this.options.afterInstall, "after-install.tpl"), templateOptions), writeConfigFile(packager.info.tempDirManager, getResource(_this.options.afterRemove, "after-remove.tpl"), templateOptions)]);
        })();
    }
    build(appOutDir, arch) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const target = _this2.name;
            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).log)(`Building ${target}`);
            // tslint:disable:no-invalid-template-strings
            let nameFormat = "${name}-${version}-${arch}.${ext}";
            let isUseArchIfX64 = false;
            if (target === "deb") {
                nameFormat = "${name}_${version}_${arch}.${ext}";
                isUseArchIfX64 = true;
            } else if (target === "rpm") {
                nameFormat = "${name}-${version}.${arch}.${ext}";
                isUseArchIfX64 = true;
            }
            const destination = _path.join(_this2.outDir, _this2.packager.expandArtifactNamePattern(_this2.options, target, arch, nameFormat, !isUseArchIfX64));
            yield (0, (_fs || _load_fs()).unlinkIfExists)(destination);
            if (_this2.packager.packagerOptions.prepackaged != null) {
                yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_this2.outDir);
            }
            const scripts = yield _this2.scriptFiles;
            const packager = _this2.packager;
            const appInfo = packager.appInfo;
            const projectUrl = yield appInfo.computePackageUrl();
            if (projectUrl == null) {
                throw new Error("Please specify project homepage, see https://github.com/electron-userland/electron-builder/wiki/Options#Metadata-homepage");
            }
            const options = _this2.options;
            let author = options.maintainer;
            if (author == null) {
                const a = packager.info.metadata.author;
                if (a.email == null) {
                    throw new Error((_errorMessages || _load_errorMessages()).authorEmailIsMissed);
                }
                author = `${a.name} <${a.email}>`;
            }
            const synopsis = options.synopsis;
            const args = ["-s", "dir", "-t", target, "--architecture", target === "pacman" && arch === (_electronBuilderUtil || _load_electronBuilderUtil()).Arch.ia32 ? "i686" : (0, (_electronBuilderUtil || _load_electronBuilderUtil()).toLinuxArchString)(arch), "--name", appInfo.name, "--force", "--after-install", scripts[0], "--after-remove", scripts[1], "--description", (0, (_electronBuilderUtil || _load_electronBuilderUtil()).smarten)(target === "rpm" ? _this2.helper.getDescription(options) : `${synopsis || ""}\n ${_this2.helper.getDescription(options)}`), "--maintainer", author, "--vendor", options.vendor || author, "--version", appInfo.version, "--package", destination, "--url", projectUrl];
            if ((_electronBuilderUtil || _load_electronBuilderUtil()).debug.enabled) {
                // args.push(
                //   "--log", "debug",
                //   "--debug")
            }
            const packageCategory = options.packageCategory;
            if (packageCategory != null && packageCategory !== null) {
                args.push("--category", packageCategory);
            }
            if (target === "deb") {
                args.push("--deb-compression", options.compression || (packager.config.compression === "store" ? "gz" : "xz"));
                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(options.priority, function (it) {
                    return args.push("--deb-priority", it);
                });
            } else if (target === "rpm") {
                args.push("--rpm-os", "linux");
                if (synopsis != null) {
                    args.push("--rpm-summary", (0, (_electronBuilderUtil || _load_electronBuilderUtil()).smarten)(synopsis));
                }
            }
            // noinspection JSDeprecatedSymbols
            let depends = options.depends || _this2.packager.platformSpecificBuildOptions.depends;
            if (depends == null) {
                if (target === "deb") {
                    depends = ["gconf2", "gconf-service", "libnotify4", "libappindicator1", "libxtst6", "libnss3", "libxss1"];
                } else if (target === "pacman") {
                    // noinspection SpellCheckingInspection
                    depends = ["c-ares", "ffmpeg", "gtk3", "http-parser", "libevent", "libvpx", "libxslt", "libxss", "minizip", "nss", "re2", "snappy", "libnotify", "libappindicator-gtk2", "libappindicator-gtk3", "libappindicator-sharp"];
                } else if (target === "rpm") {
                    depends = ["libnotify", "libappindicator"];
                } else {
                    depends = [];
                }
            } else if (!Array.isArray(depends)) {
                if (typeof depends === "string") {
                    depends = [depends];
                } else {
                    throw new Error(`depends must be Array or String, but specified as: ${depends}`);
                }
            }
            for (const dep of depends) {
                args.push("--depends", dep);
            }
            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(packager.info.metadata.license, function (it) {
                return args.push("--license", it);
            });
            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(appInfo.buildNumber, function (it) {
                return args.push("--iteration", it);
            });
            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(options.fpm, function (it) {
                return args.push.apply(args, _toConsumableArray(it));
            });
            args.push(`${appOutDir}/=${(_LinuxTargetHelper || _load_LinuxTargetHelper()).installPrefix}/${appInfo.productFilename}`);
            for (const mapping of yield _this2.helper.icons) {
                args.push(mapping.join("=/usr/share/icons/hicolor/"));
            }
            const desktopFilePath = yield _this2.helper.computeDesktopEntry(_this2.options);
            args.push(`${desktopFilePath}=/usr/share/applications/${_this2.packager.executableName}.desktop`);
            if (_this2.packager.packagerOptions.effectiveOptionComputed != null && (yield _this2.packager.packagerOptions.effectiveOptionComputed([args, desktopFilePath]))) {
                return;
            }
            const env = Object.assign({}, process.env, { LANG: "en_US.UTF-8", LC_CTYPE: "UTF-8" });
            // rpmbuild wants directory rpm with some default config files. Even if we can use dylibbundler, path to such config files are not changed (we need to replace in the binary)
            // so, for now, brew install rpm is still required.
            if (target !== "rpm" && (yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).isMacOsSierra)())) {
                const linuxToolsPath = yield (0, (_bundledTool || _load_bundledTool()).getLinuxToolsPath)();
                Object.assign(env, {
                    PATH: (0, (_bundledTool || _load_bundledTool()).computeEnv)(process.env.PATH, [_path.join(linuxToolsPath, "bin")]),
                    DYLD_LIBRARY_PATH: (0, (_bundledTool || _load_bundledTool()).computeEnv)(process.env.DYLD_LIBRARY_PATH, [_path.join(linuxToolsPath, "lib")])
                });
            }
            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)((yield fpmPath), args, { env });
            _this2.packager.dispatchArtifactCreated(destination, _this2, arch);
        })();
    }
}
exports.default = FpmTarget;