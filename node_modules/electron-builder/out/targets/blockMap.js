"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.computeBlockMap = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

let computeBlocks = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (inputFile, stat) {
        const fd = yield (0, (_fsExtraP || _load_fsExtraP()).open)(inputFile, "r");
        const chunkSize = 64 * 1024;
        const buffer = Buffer.allocUnsafe(chunkSize);
        const size = stat.size;
        const blocks = [];
        for (let offset = 0; offset < size; offset += chunkSize) {
            const actualChunkSize = Math.min(size - offset, chunkSize);
            yield (0, (_fsExtraP || _load_fsExtraP()).read)(fd, buffer, 0, actualChunkSize, offset);
            const hash = (0, (_crypto || _load_crypto()).createHash)("sha256");
            hash.update(actualChunkSize === chunkSize ? buffer : buffer.slice(0, actualChunkSize));
            blocks.push(hash.digest("base64"));
        }
        return blocks;
    });

    return function computeBlocks(_x, _x2) {
        return _ref.apply(this, arguments);
    };
})();

let computeBlockMap = exports.computeBlockMap = (() => {
    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (appOutDir) {
        const files = new Map();
        yield (0, (_fs || _load_fs()).walk)(appOutDir, null, {
            consume: function (file, fileStat) {
                if (fileStat.isFile()) {
                    files.set(file, fileStat);
                }
            }
        });
        const info = [];
        for (const _ref3 of files.entries()) {
            var _ref4 = _slicedToArray(_ref3, 2);

            const file = _ref4[0];
            const stat = _ref4[1];

            const blocks = yield computeBlocks(file, stat);
            info.push({ name: file.substring(appOutDir.length + 1).replace(/\\/g, "/"), blocks });
        }
        return (0, (_jsYaml || _load_jsYaml()).safeDump)(info);
    });

    return function computeBlockMap(_x3) {
        return _ref2.apply(this, arguments);
    };
})();
//# sourceMappingURL=blockMap.js.map


var _crypto;

function _load_crypto() {
    return _crypto = require("crypto");
}

var _fs;

function _load_fs() {
    return _fs = require("electron-builder-util/out/fs");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = require("js-yaml");
}